<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo博客的使用]]></title>
    <url>%2F2019%2F09%2F07%2Fhexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[如何使用hexo写博客 自从博客建好后，我继续我的前端学习，边学边记了些笔记，今天想发在博客上时，突然发现有些忘记hexo如何用了,于是我想简单的记一记。 首先，官方文档 新建博客文章(posts)：先在博客目录下打开命令行，再执行命令$ hexo new &lt;title&gt; 分类与标签的设置(分类具有顺序性和层次性,而标签没有)： 12345categories:- Diarytags:- PS3- Games 写完文章后的部署与发布：$ hexo clean &amp;&amp;hexo g &amp;&amp;gulp &amp;&amp;hexo d]]></content>
      <categories>
        <category>新手上路</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webNote]]></title>
    <url>%2F2019%2F09%2F07%2FwebNote%2F</url>
    <content type="text"><![CDATA[HTML+CSS+JavaScriptHTMLHTML简介 什么是HTML? HTML 指的是超文本标记语言(HyperText Markup Language),是用来描述网页的一种语言。 大多数HTML元素包含开标签和闭标签，两者之间又包含纯文本或其他HTML标签。 HTML元素能被嵌入其他标签，被包围的元素是外围父元素的孩子。 任何可见内容必须放在&lt;body&gt;标签的开闭标签之间。 标题&lt;h1&gt;到&lt;h6&gt;。 &lt;p&gt;(paragraph)，&lt;span&gt;与&lt;div&gt;(division)标签表示文本或块元素。 &lt;em&gt;与&lt;strong&gt;用来强调文本。 换行用&lt;br&gt;(line break)标签。 &lt;ol&gt;(ordered lists)是有序表，&lt;ul&gt;(unordered lists)是无序表。 &lt;img&gt;(images)与&lt;video&gt;(videos)分别连接图片与视频资源。 HTML文档标准 &lt;!DOCTYPE html&gt;需在html文件首行，告诉浏览器HTML的版本。 &lt;html&gt;元素包含所有html代码。 网页的信息，如标题等，定义在&lt;head&gt;中。 网页的标题定义在head中的&lt;title&gt;里。 网页的标题显示在浏览器的标签栏里。 &lt;a&gt;(anchor)标签用来连接外部网页，内部网页或者当前网页其他部分内容。 可以通过&lt;a&gt;结合id跳转到当前网页的其他部分。 通过空格和缩进增强可读性。 用&lt;!-- comment --&gt;注释。 更多html标签参考Mozilla documentation。 HTML表格 用&lt;table&gt;标签制作表格。 &lt;tr&gt;(table rows)添加表格行。 &lt;td&gt;(table data)添加表格数据。 &lt;th&gt;(table heading)添加行标题或列标题。 colspan属性设置跨列单元格。 rowspan属性设置跨行单元格。 表格可分为三部分：头，主体，脚。 表头用&lt;thead&gt;表示。(表格标题) 主体用&lt;tbody&gt;表示。(表头与数据) 脚用&lt;tfoot&gt;表示。(表格描述) HTML表单 &lt;form&gt;表示表单。 &lt;form&gt;的action属性设置表单提交到哪。 &lt;form&gt;的method属性设置表单提交方式。 &lt;input&gt;元素： type属性为&quot;text&quot;是单行文本输入框。 type属性为&quot;password&quot;是密码输入框。 type属性为&quot;number&quot;是数值输入框。 type属性为&quot;range&quot;是滑动条。 type属性为&quot;checkbox&quot;是复选框。 type属性为&quot;radio&quot;是单选框。 type属性为&quot;list&quot;搭配&lt;datalist&gt;可输入的下拉框。 type属性为&quot;submit&quot;是提交表单按钮。 &lt;select&gt;是不可输入的下拉框，&lt;option&gt;设置选项。 &lt;datalist&gt;是配合&lt;input&gt;使用的数据表，&lt;option&gt;设置选项。 &lt;textarea&gt;是大的文本输入框。 当表单被提交时，各个元素的name与value会以name=value的形式成对发送。 placeholder属性可以设置提示信息，当用户键入或选中时消失。 HTML表单客户端校验 客户端校验发生在表单被送到服务端之前。 requried属性要求必须有输入，不可为空。 min属性规定输入数值的最小值。 max属性规定输入数值的最大值。 maxlength属性规定文本输入长度的最大值。 minlength属性规定文本输入长度的最小值。 pattern属性要求输入匹配相应的正则式。 如果表单校验不通过，用户会得到相应的提示信息。 含语义的HTML 含语义的HTML通过特定标签内包含特定内容的方式告诉页面其含义。 含语义的HTML是一种标准，使网页便于人们阅读，改善SEO。 &lt;header&gt;、&lt;nav&gt;、&lt;main&gt;、footer构成基本的网页结构。 &lt;section&gt;定义文档同一主题下的元素，例如章节、标题、或文档的其他区域。 &lt;article&gt;包含文章、博客、评论等内容。 &lt;aside&gt;包含与主要内容相关，但对理解主要内容来说又不是必须的。 &lt;figure&gt;用来包装各种类型的媒体资源。 &lt;figcaption&gt;用来描述&lt;figure&gt;的标题。 &lt;video&gt;、&lt;embed&gt;、&lt;audio&gt;用来打开媒体资源。 CSSCSS的建立与选择器 CSS(cascading style sheet)即层叠样式表能改变HTML元素的样式，CSS必须先选择HTML元素，然后将样式应用到所选元素上。 CSS可通过标签名，类名，ID名选择HTML元素。 一个HTML元素可以有多个类名，用空格隔开。 类可以多次使用，ID只能有一个。 优先级：ID选择器&gt;类选择器&gt;元素选择器。 多个选择器可串联起来选择元素，这会提高它的优先级。(如div.classname，div#IDname) 内嵌元素可以通过后代选择器选择，即选择器间用空格隔开。 属性值加上!important后优先级最高，几乎很难被覆盖。 多个选择器可共用同一样式代码，选择器间通过逗号隔开。 CSS规则 CSS声明由属性与值组成。 font-family属性定义元素的字体。 font-size控制文本的字体大小。 font-weight定义文本字体粗细，通常有bold与normal两个值。 text-align属性定义文本对齐方式，通常有left，right，center三种方式。 文本有两种不同的颜色属性color与background-color，color定义文本前景色，background-color定义文本背景色。 CSS通过opacity属性控制元素透明度，为1时是可见的、不透明，为0时是不可见的、透明的。 CSS通过background-image属性设置元素背景图片。 CSS盒模型 盒模型由内容，内边距，边框，外边距组成，如下图。 内容的宽和高以px或百分比为单位。 边框内包含内边距与内容区域。边框的粗细、样式、颜色可以通过CSS属性设置。 填充区(内边距)是内容与边框之间的区域，以px或百分比为单位。 外边距是边框外的区域。 水平上的外边距相加，总距离等于相邻元素的外边距相加。 垂直方向的外边距坍塌(合并)，总距离等于相邻元素中比较大的外边距，如下图。 margin: 0 auto使元素在父元素中水平居中，如果它有宽度的话。 overflow属性可被设置成display、hide、scroll,规定该元素超出父元素后如何渲染。 visibility属性可以隐藏或显示元素。 visibility:hide与display:none不同于：visibility:hide元素只是不可见，所占空间还在，display:none元素不仅不可见，所占空间也被删除。 改变CSS盒模型 默认的盒模型中，长和宽是内容的长与宽，不包括边框与填充，盒的大小受到边框与填充的影响。如下图。 box-sizing属性控制浏览器的盒模型。 box-sizing默认值为content-box。 新的盒模型值为border-box。 border-box中盒的大小不受边框与填充的影响。如下图。 CSS展示与定位 position属性允许通过三种方式定位元素，默认为static。 position设为relative时，元素相对默认位置进行偏移，还在HTML文档流中。 top - 元素顶部偏移距离，即元素向下移动距离。 bottom - 元素底部偏移距离，即元素向上移动距离。 left- 元素左部偏移距离，即元素向右移动距离 right - 元素右部偏移距离，即元素向左移动距离 position设为absolute时，元素相对最近的父元素进行偏移，脱离HTML正常文档流。当页面滚动时，该元素会随之滚动。 position设为fixed时，元素会固定在页面的某一位置，不随页面滚动。 z-index规定元素的层级，层级高的元素会覆盖其它层级低的元素，对static的元素不起作用。 display属性设置元素为内联元素(inline)、块级元素(block)、内联块(inline-block)。 inline元素占尽量小的空间，无法设置width与height属性。 block元素占满容器的宽度，可以设置height属性。 inline-block可以设置width与height属性，它们挤在一起，不占满容器宽度。 float属性可使元素在页面的最左边或最右边。 可以用clear属性清除元素左边或右边或两边的浮动。 left – 元素左边不允许接触容器中的其他元素。 right– 元素右边不允许接触容器中的其他元素。 both – 元素两边不允许接触容器中的其他元素。 none – 元素两边允许其他元素。 CSS颜色在CSS中一共四种设置颜色的方法： 颜色名–一共147种颜色名。 16进制表示颜色： 十六进制为09，剩下1015用A~F表示。 16进制颜色以#开头，接上红绿蓝颜色值，如#23F41A。 RGB(red,green,blue) RGB颜色用rgb()表示，三个参数依次表示红、绿、蓝的颜色值。 RGB的范围从0到255，例如rgb(7, 210, 50)。 HSL(hue,saturation,lightness) HSL分别表示色彩、饱和度、亮度。 色彩范围从0到360，饱和度与亮度用百分比表示，例如hsl(200, 20%, 50%)。 可以在RGB与HSL中加上第四个值，a(Alpha)透明度，范围从0到1。如rgba(7, 210, 50, 0.5)或hsla(200, 20%, 50%, 0.5) CSS字体与排版 字体粗细用font-weight设置，范围从100到900，值为100的倍数。 400是默认值normal。 700表示值bold。 300表示值light。 font-style值为italic时字体倾斜。 行间距可用行高line-height设置。 有衬线字体(serif)字末端有细节，而无衬线字体(sans-serif)没有。 当用户计算机没有安装所选字体时，选用备用字体(Fallback fonts)。 可用&lt;link&gt;在HTML中引入字体库，或用@font-face在CSS中引入字体库。 word-spacing用来设置词间距。 letter-spacing用来设置字间距。 text-align用来设置文本对齐方式。 CSS网格 容器元素需设置display为grid; grid-template-columns定义网格的列数与列宽，声明时只列出列宽，有几个列宽表示有几列，特定单位fr表示可用空间的片段，若有n个片段，每个片段占1/n的长度。 grid-template-rows定义网格的行数与行高，声明时只列出行高，有几个行高表示有几行。 grid-template将grid-template-rows与grid-template-columns合并定义，用/隔开。 grid-gap设置行间隙与列间隙。 grid-row-start与grid-row-end设置元素横跨那些行，若横跨第4、5行，截至行为6。 grid-column-start与grid-column-end设置元素横跨那些列。 grid-area将grid-row-start、grid-column-start、grid-row-end与grid-column-end按顺序合并，用/隔开。 CSS网格进阶 grid-template-area可以设置网格区域及其名称。声明一个名称为一个区域，同一行的区域在同一双引号中。 justify-items设置元素在网格中水平方向的对齐方式，在容器中设置。 start–元素在网格中左对齐。 end–元素在网格中右对齐。 center–元素在网格中水平居中。 stretch–元素水平拉伸充满网格，如果某一元素有特定的宽将不做拉伸。 justify-content设置网格在容器中水平方向的对齐方式，在容器中设置。 start–网格在容器中左对齐。 end–网格在容器中右对齐。 center–网格在容器中水平居中。 stretch–网格水平拉伸充满容器。 space-around–水平方向上，用空白填充网格两边，会使网格间空白是边缘空白的两倍。 space-between–水平方向上，用空白填充网格间隙，边缘没有空白。 space-evenly–水平方向上，用空白均等地填充网格两边与边缘。 justify-self规定某一个元素的水平对齐方式，在元素中设置，值同justify-items。 align-items设置元素在网格中垂直方向的对齐方式，在容器中设置，值与justify-items类似。 align-content设置网格在容器中垂直方向的对齐方式，在容器中设置，值与justify-content类似。 align-self规定某一个元素的垂直对齐方式，在元素中设置，值同align-items。 grid-auto-rows设置自动添加的行的行高，增加网格可变性。 grid-auto-columns设置自动添加的列的列宽，增加网格可变性。 grid-auto-flow设置元素个数超出网格数时，网格自动添加的方式。 row–自动添加行。(默认) column–自动添加列。 dense(密集的)–如果有小块元素会通过算法填充到之前留下的洞中，可以与row、column搭配使用，例如grid-auto-flow: row dense;。 JavaScriptJavaScript简介 可用console.log查看数据。 单行注释用//，多行注释用/*与*/。 JavaScript中有7种基本数据类型：strings(字符串)、numbers(数字)、booleans(布尔类型)、null(空)、undefined(未定义)、symbol(唯一标识)、object(对象)。 数字不需要引号：23.8879。 字符串需要单引号或双引号：Sample String。 内嵌的算术运算符有+、-、*、/、%(取余)。 对象具有属性，查看属性用对象名+.+属性名：&#39;Hello&#39;.length。 对象具有方法，调用方法通过对象名+.+方法名+()：&#39;hello&#39;.toUpperCase()。 JavaScript内嵌对象包括Math等,是一些方法与属性的聚合体。 变量 变量储存程序中反复用的数据，通过变量名使用数据。 变量存储在内存中。 var是在ES6之前的版本中使用的关键词。 let是更好的声明变量(可重新赋值)的方法，const是更好的声明常量(不可重新赋值)的方法。 未初始化的变量值为undefined。 算术赋值：+=、-=、*=、/=、++、--。 +也用来联结字符串或字符串变量。 在ES6中，模板字符串通过反引号`与${}来插入值，例如： 123const myPet = &apos;armadillo&apos;;console.log(`I own a pet $&#123;myPet&#125;.`);// Output: I own a pet armadillo. typeof用来返回数据类型(返回的是一个字符串)。 条件语句 if条件语句：当if条件为true时执行代码。 if...else语句：当if条件为true时执行if代码块，为false时执行else代码块。 可用else if添加更多条件。 比较运算：&lt;、&gt;、&lt;=、&gt;=、===(相等)、!==(不等)。 逻辑运算：&amp;&amp;(与)、||(或)、!(非)。 假值有0，空字符串&quot;&quot;或&#39;&#39;，null，undefined，NaN。 可用短路求值(short-circuit evaluation)，例如let defaultName = username || &#39;Stranger&#39;;。 三目运算符：判断条件 ? 条件为真时执行的代码 : 条件为假时执行的代码。 switch与case是另一种条件判断方式，每个case中需要break。 函数 函数声明： 带参数的函数声明： 调用函数： ES6提供了参数默认值(default parameters)的声明： 123456function greeting (name = &apos;stranger&apos;) &#123; console.log(`Hello, $&#123;name&#125;!`)&#125;greeting(&apos;Nick&apos;) // Output: Hello, Nick!greeting() // Output: Hello, stranger! 设置函数返回值用return语句。 定义函数表达式： 箭头函数表示法： 通过箭头函数简化函数定义： 箭头函数中只有一个参数可省略括号，0个或多个参数不能省略。 箭头函数中代码块只有一行时可省略花括号与return。 作用域 作用域是一个程序中变量的作用范围。 (代码)块是被花括号{}包含的代码。 全局作用域是指变量在任何地方都有效。 全局变量是指在任何地方都有效的变量。 块作用域是指变量只在当前代码块有效。 本地变量是指只在当前代码块有效的变量。 全局命名空间是指存储全局作用域信息的空间。 作用域污染是指命名空间存储过多变量或者变量名重复使用。 数组 创建数组：[]表示数组，数据项用,隔开。数组中可以存不同类型的数据。 下标从0开始。 可以通过下标取得数据：myArr[0]。 let与const分配的数组都可以改变数组中某项的值，但const不能重新分配新的数组，let可以。 可通过length属性获得数组长度。 .push()与.pop()方法分别添加与删除数组的最后一个元素。 .unshift()与.shift()方法分别添加与删除数组的第一个元素。 .slice()从数组中取出一些元素，不改变数组。 数组在函数中被改变，在函数外也同样被改变。因为数组是作为引用传给函数的。 数组可嵌套其他数组：1234const nestedArr = [[1], [2, 3]];console.log(nestedArr[1]); // Output: [2, 3]console.log(nestedArr[1][0]); // Output: 2 循环 for循环： 123for (let counter = 0; counter &lt; 4; counter++) &#123; console.log(counter);&#125; while循环： 1234567891011// A for loop that prints 1, 2, and 3for (let counterOne = 1; counterOne &lt; 4; counterOne++)&#123; console.log(counterOne);&#125;// A while loop that prints 1, 2, and 3let counterTwo = 1;while (counterTwo &lt; 4) &#123; console.log(counterTwo); counterTwo++;&#125; do...while循环：(至少执行一次代码) 1234567let countString = &apos;&apos;;let i = 0;do &#123; countString = countString + i; i++;&#125; while (i &lt; 5); break跳出循环。 高阶函数 函数可以被当作数据处理，可以赋予它新的值。 Javascript函数也是对象(first-class objects)，所以它有属性与方法。 函数可作为参数传递给其他函数。 高价函数：参数是函数、返回值是函数、或者两者都有。12345678910const timeFuncRuntime = funcParameter =&gt; &#123; let t1 = Date.now(); funcParameter(); let t2 = Date.now(); return t2 - t1;&#125;const addOneToOne = () =&gt; 1 + 1;timeFuncRuntime(addOneToOne); 迭代器 .forEach()对数组中每个元素执行相同代码并返回undefined。 .map()对数组中每个元素执行相同代码并返回新的数组，原数组不变。 12345678const numbers = [1, 2, 3, 4, 5]; const bigNumbers = numbers.map(number =&gt; &#123; return number * 10;&#125;);console.log(numbers); // Output: [1, 2, 3, 4, 5]console.log(bigNumbers); // Output: [10, 20, 30, 40, 50] .filter()查看数组中每个元素，返回符合条件的数的数组。 12345678const words = [&apos;chair&apos;, &apos;music&apos;, &apos;pillow&apos;, &apos;brick&apos;, &apos;pen&apos;, &apos;door&apos;]; const shortWords = words.filter(word =&gt; &#123; return word.length &lt; 6;&#125;);console.log(words); // Output: [&apos;chair&apos;, &apos;music&apos;, &apos;pillow&apos;, &apos;brick&apos;, &apos;pen&apos;, &apos;door&apos;]; console.log(shortWords); // Output: [&apos;chair&apos;, &apos;music&apos;, &apos;brick&apos;, &apos;pen&apos;, &apos;door&apos;] .findIndex()查看数组中每个元素，返回第一个符合条件的数的下标。如果没有就返回-1。 123456const jumbledNums = [123, 25, 78, 5, 9]; const lessThanTen = jumbledNums.findIndex(num =&gt; &#123; return num &lt; 10;&#125;);console.log(lessThanTen); // Output: 3 .reduce()查看数组中每个元素，返回一个值。 1234567const numbers = [1, 2, 4, 10];const summedNums = numbers.reduce((accumulator, currentValue) =&gt; &#123; return accumulator + currentValue&#125;)console.log(summedNums) // Output: 17 Iteration accumulator currentValue return value First 1 2 3 Second 3 4 7 Third 7 10 17 .reduce()的第二个参数可初始化accumulator： 1234567 const numbers = [1, 2, 4, 10];const summedNums = numbers.reduce((accumulator, currentValue) =&gt; &#123; return accumulator + currentValue&#125;, 100) // &lt;- Second argument for .reduce()console.log(summedNums); // Output: 117 Iteration accumulator currentValue return value First 100 1 101 Second 101 2 103 Third 103 4 107 Fourth 107 10 117 迭代方法以回调函数为参数，回调函数需要提前定义，或者用函数表达式，或者箭头函数。 对象 对象是键值对的集合，每个键值对都是一个属性，当属性为函数时被称作方法。 一个对象字由包裹在花括号的逗号分隔的键值对组成。 可以通过点或方括号取得对象的属性。 可通过键值对(值为匿名表达式)或ES6的新语法为对象添加方法。 1234567891011const alienShip = &#123; invade: function () &#123; console.log(&apos;Hello! We have come to dominate your planet. Instead of Earth, it shall be called New Xaculon.&apos;) &#125;&#125;;const alienShip = &#123; invade () &#123; console.log(&apos;Hello! We have come to dominate your planet. Instead of Earth, it shall be called New Xaculon.&apos;) &#125;&#125;; 对象中可以嵌入对象。 对象是可变的，即使被声明为const。 对象通过引用传递，当我们在函数中改变了对象内容，这些改变时永久的。 可通过For...in遍历对象。 1234// for...infor (let crewMember in spaceship.crew) &#123; console.log(`$&#123;crewMember&#125;: $&#123;spaceship.crew[crewMember].name&#125;`)&#125;; 对象进阶 方法所属的对象称为调用对象，this指调用对象，可被用来取得调用对象的属性。 方法不会自动取得调用对象的其他内部属性。 this不能用在箭头函数中，因为箭头函数中的this指全局对象，而不是调用对象。 JavaScript对象没有内嵌的私有属性，可在属性名前加_表示私有属性，告诉其他开发者不能直接改变该属性。即使如此，它还是可以被直接改变。 12345const bankAccount = &#123; _amount: 1000&#125;bankAccount._amount = 1000000; Setters与getter方法用来设置与取得属性值。 setter方法 1234567891011121314const person = &#123;_firstName: &apos;John&apos;,_lastName: &apos;Doe&apos;,get fullName() &#123; if (this._firstName &amp;&amp; this._lastName)&#123; return `$&#123;this._firstName&#125; $&#123;this._lastName&#125;`; &#125; else &#123; return &apos;Missing a first name or a last name.&apos;; &#125;&#125;&#125;// To call the getter method: person.fullName; // &apos;John Doe&apos; getter方法 12345678910111213const person = &#123; _age: 37, set age(newAge)&#123; if (typeof newAge === &apos;number&apos;)&#123; this._age = newAge; &#125; else &#123; console.log(&apos;You must assign a number to age&apos;); &#125; &#125;&#125;;person.age = 40;console.log(person._age); // Logs: 40person.age = &apos;40&apos;; // Logs: You must assign a number to age Factory(工厂)函数使我们能快速的创建多个对象实例。 12345678910const monsterFactory = (name, age, energySource, catchPhrase) =&gt; &#123; return &#123; name: name, age: age, energySource: energySource, scare() &#123; console.log(catchPhrase); &#125; &#125;&#125;; 对象的变形： 属性值简写： 123456const monsterFactory = (name, age) =&gt; &#123; return &#123; name, age &#125;&#125;; 变形赋值： 123456//正常赋值const residence = vampire.residence; console.log(residence); // Prints &apos;Transylvania&apos;//变形赋值const &#123; residence &#125; = vampire; console.log(residence); // Prints &apos;Transylvania&apos; 类 类是对象的模板。 JavaScript构造函数为constructor()。 继承使子类可以获得父类的属性与方法。 用extends创建子类。 用super调用父类的construct()。 1234567891011121314151617181920212223242526272829303132//父类class Animal &#123; constructor(name) &#123; this._name = name; this._behavior = 0; &#125; get name() &#123; return this._name; &#125; get behavior() &#123; return this._behavior; &#125; incrementBehavior() &#123; this._behavior++; &#125;&#125; //子类class Cat extends Animal &#123; constructor(name, usesLitter) &#123; super(name); this._usesLitter = usesLitter; &#125; get usesLitter() &#123; return this._usesLitter; &#125;&#125;//实例化const bryceCat = new Cat(&apos;Bryce&apos;, false); 用static定义静态方法，只能用类名调用，不能实例化再调用。 12345678910111213141516class Animal &#123; constructor(name) &#123; this._name = name; this._behavior = 0; &#125; static generateName() &#123; const names = [&apos;Angel&apos;, &apos;Spike&apos;, &apos;Buffy&apos;, &apos;Willow&apos;, &apos;Tara&apos;]; const randomNumber = Math.floor(Math.random()*5); return names[randomNumber]; &#125;&#125;//调用静态方法console.log(Animal.generateName()); // returns a nameconst tyson = new Animal(&apos;Tyson&apos;); tyson.generateName(); // TypeError 浏览器兼容与转换 ES5–Javascript的老版本，所有浏览器都支持。 ES6–Javascript的新版本，部分浏览器不支持。语法更简洁，更具可读性，解决了一些ES5普遍的bug。 caniuse–一个用来查找HTML、CSS、Javascript兼容信息的网站。 Babel–一个将ES6+代码转换成ES5的Javascript包。 npm init–建立package.json文件的终端命令，package.json是一个包含Javascript工程信息的文件。 npm install–安装节点包(Node package)的命令。 12npm install babel-cli -Dnpm install babel-preset-env -D babel-cli–一个包含Babel命令行工具的节点包。 babel-preset-env–一个包含ES6+到ES5的映射信息的节点包。 .babelrc–一个包含Javascript源码的版本信息的文件。 123&#123;&quot;presets&quot;: [&quot;env&quot;]&#125; &quot;build&quot;脚本–一个将ES6+代码转换成ES5的package.json脚本。 1&quot;build&quot;: &quot;babel src -d lib&quot; npm run build–一个执行”build”脚本ES6+代码转换成ES5的命令。 Javascript模块(module) 模块在Node.js中是能被反复利用的代码块，能从一个项目中导出，导入到另一项目中。 module.exports将模块导出。 1234let Menu = &#123;specialty:&quot;Roasted Beet Burger with Mint Sauce&quot;&#125;;module.exports = Menu; //另一形式：module.exports =&#123;specialty:&quot;Roasted Beet Burger with Mint Sauce&quot;&#125;; require()将模块导入。 12345const Menu = require(&apos;./menu.js&apos;);function placeOrder() &#123; console.log(&apos;My order is: &apos; + Menu.specialty);&#125;placeOrder(); ES6具有更灵活、简单的语法： 默认导出–export default可导出Javascript对象、函数与基本数据类型。 12let Menu = &#123;&#125;;export default Menu; 命名导出–export可为变量起别名再导出。 123456789101112let specialty = &apos;&apos;;function isVegetarian() &#123;&#125;; function isLowSodium() &#123;&#125;; export &#123; specialty, isVegetarian &#125;;//或者：export let specialty = &apos;&apos;;export function isVegetarian() &#123;&#125;; function isLowSodium() &#123;&#125;; as为变量起别名。 1export &#123; specialty as chefsSpecial, isVegetarian as isVeg,isLowSodium &#125;; import导入对象、函数或基本数据类型。 123import Menu from &apos;./menu&apos;;//命名导入：import &#123; specialty, isVegetarian &#125; from &apos;./menu&apos;; Javascript Promise(承诺将来会执行) Promise是Javascript对象，代表一个异步操作的最终结果。 Promise有三种状态：pending(待定)、resolved(解决)、rejected(拒绝)。 当Promise为resolved或rejected时是确定的(settled)。 我们通过关键字new构建Promise对象，并向构建方法传递执行函数作为参数。 setTimeout()是一个Node函数，用事件循环(the event-loop)延迟回调函数的执行。 .then()以成功处理时的回调函数为参数，包含Promise解决后所做的事。 .catch()以失败处理时的回调函数为参数，包含Promise拒绝后所做的事。 可以将.then()与.catch()串联起来，用于处理有依赖关系的按顺序的多个任务。 为保证Promise组合的正确，每个.then()中都要返回一个Promise。 串联Promise比内嵌Promise好。 同时执行多个异步操作用Promise.all()，用于处理并行的多个任务。 ASYNC AWAIT(异步等待) async...await是由Javascript promise生成的语法糖(通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会)。 我们用关键字async声明异步函数。 在async函数中我们用await暂停当前函数直到异步操作完成。 await返回Promise中的resolved value(解决值)。 我们可以像同步语法一样用多个await。 在async函数中可用try...catch语句处理错误。 在async函数中可用await Promise.all()处理并行异步操作。 Request I JavaScript是一种具有异步能力的网络语言。AJAX表示Asynchronous JavaScript and XML，是一种用来实现Javascript异步能力的工具。 HTTP具有许多种请求方式，主要有GET与POST。 GET方法只向其他来源请求信息。 POST方法除了只向其他来源请求信息，还向其他来源传输信息。 GET请求能用XMLHttpRequest对象与Javascript来写。 POST请求也能用XMLHttpRequest对象与Javascript来写。 GET与POST请求需要用new创建一个XHR对象，设置其responseType，创建一个函数处理响应对象(response)，以及打开(open)与发送(send)请求。 为了在URL末端添加查询字符串(query string)可用?再添上参数。 为了提供多个参数，用&amp;隔开键值对，用=赋值。 Request II GET与POST请求有许多种创建方式。 fetch()与async/await是用来异步请求数据的函数。 fetch+GET fetch+POST async+await+GET async+await+POST fetch()是个web API，用来创建request，fetch()返回一个Promise。 我们可以串联.then()来处理fetch()返回的Promise。 .json()方法将Promise转换为JSON对象。 async用来创建返回Promise的函数。 await用来告诉程序当Promise解决时再继续。 await只在async函数中使用。]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello World 你好，世界 不管我学何种编程语言，首先学的都是如何输出hello world，现在终于创建了自己的博客，我也写一篇hello world,记一记我在搭建个人博客中的一些感想吧。 创建个人博客的原由 自从学了JAVA后，尤其是在用JavaEE与tomcat完成一个模仿酒店订单的webapp后，我对前后端起了兴趣，开始了解起一个真正的网站是如何构建的。了解了域名、服务器、图床等概念，接触了html、css、javascript、mysql。渐渐的，我萌发了搭建个人博客的念头，想尝试下一个博客网站如何搭建，同时也想写点什么，整理所学知识。于是我开始搜集一些搭建博客的教程与资料。 搭建博客的过程 在搜索了众多资料，参考了众多大牛的博客后，我选择了hexo+github的方式搭建我的博客，主要参考了GitHub+Hexo 搭建个人网站详细教程这篇博客。而且为了实践下所学，我尝试着创建个人主题，参考了“不可能不确定”的Hexo 主题开发指南与MARKSZのBlog的博客，但最后发现我对html、css、js十分生疏，尤其是javasript。也怪我学的时候太心急，只看教程，从未动手实践，实际写代码的时候就是不知从何写起，不断地查文档。于是个人主题的创建就此暂停了，我打算先从头开始跟着教程把代码实际码一遍，等我真正熟悉这些语言时，希望我能拥有一个属于自己的hexo主题吧。 个人博客的搭建结果 最终我选择了next主题，因为它黑白搭配的风格挺适合我的。而对next主题的美化，我主要参考了Hexo博客优化之Next主题美化与hexo的next主题个性化教程这两篇博客。改好配置后，在本机试验了下，效果还不错，于是hexo d发布，完成了我的个人博客。 域名绑定 有了个人博客，我就想有个域名了，毕竟user.github.io的网址有点长，于是为了个性化，我在阿里云注册了个.top的域名。而在设置域名解析时，由于担心github的IP变动，我用的CNAME解析，包括了@与www两条主机记录。最后我设置了githubpage自带的https，参考了官方文档，成功给博客加上了个小绿锁(^ - ^)。]]></content>
      <categories>
        <category>新手上路</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
